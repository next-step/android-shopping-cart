# android-shopping-cart

## Step4 구현 목록

- [x] Step3 피드백 반영
- [x] 상품 목록에 상품 추가 버튼 추가
- [x] 상품 추가 버튼 클릭 시 장바구니에 상품 추가
- [x] 상품 추가 버튼 클릭 시 수량 조절 버튼 노출
- [x] 상품 목록 상품 수량 변경 시 장바구니에 반영
- [x] 장바구니 상품 수량 변경 시 상품 목록에 반영
- [x] 피드백 반영

## Step4 진행 중 의식의 흐름

- 아직 컴포즈적 사고에 익숙하지 않은 것 같습니다. 상품 추가 버튼을 누른 후 수량 조절 버튼이 보이도록 하는 것에 대해 visibility 관점으로 먼저 생각을 했습니다.
  그래서 지금까지 해보지 않은 새로운 방법을 공부해야 하는 건가 싶었는데 생각해 보니 뷰 상태에 따른 리컴포지션으로 가능할 것 같습니다.
- 컴포넌트를 넘겨줄 때 Box에서 사용되는 align이 import 되지 않아서 고민이 했는데 BoxScope의 존재를 알게 되었습니다. 유레카...
- 뷰 상태를 + 버튼으로 상품 추가를 시도한 것과 하지 않은 것으로 먼저 구분하여 진행해 보니 각 상품 별로 장바구니에 추가된 상태에 대한 정보가 필요하다는 것을 깨달았습니다.
- 아이템의 + 버튼 클릭하면 리컴포지션이 발생하도록 하기 위해서 StateFlow를 사용하려고 시도하다가 각 아이템별 버튼에 대한 클릭 관리가 어려워서
  ProductActivity에서
  mutableStateOf를 사용하고 있습니다. 그런데 리컴포지션만을 위해서 해당 상태를 ProductsList까지 전달하는 것이 좋은 구조가 아닌 것 같습니다. 실제로
  ProductsList에서 buttonClickState를 사용하지는 않기 때문입니다. 리컴포지션만을 위한 이런 방식도 사용해도 괜찮을지, 더 좋은 방법은 어떤 것이 있는지
  궁금합니다.
- buttonClickState를 사용하지 않을 줄 알았지만 장바구니의 수량과 동기화 하는 과정에서 사용하게 되었습니다! 각 버튼에 대한 상태 관리라는 것은 CartItem에
  사로 잡혀서 엄청난 삽질 매몰 비용이 발생하면서 오해한 것 같습니다. 버튼은 그저 클릭 여부만 알면 목록의 리컴포지션이 가능한데, 각 목록의 각 아이템에서 리컴포지션이 필요한
  아이템만
  리컴포지션이 되는 것이 효율적이라고 생각해서 그런 생각을 했습니다. 아직 컴포즈가 익숙하지 않아 구현이 어려워서 이렇게 목록이 전체적으로 리컴포지션이 되는 방법을 사용하고
  있습니다.
- 결국 CartScreen과 ProductScreen에서 공통으로 사용하는 CartItemCountButton에 클릭 상태에 따른 리컴포지션을 위해서 다시 StateFlow를
  사용하게 되었습니다.
- 여러 삽질을 거쳐서 별도로 정리를 한번 해야겠지만 본의 아니게 상태 호이스팅에 대한 찐한 경험을 하게 된 것 같습니다. (아직 잘 지켜지고 있는지 여부와는 별개로요...)
- 하고 보니 크게 어렵지 않다고 느껴지지만 개인적으로 어려웠던 미션이었습니다. 컴포즈도 컴포즈지만 flow나 state에 대한 이해도가 부족했던 것 같습니다. 더 많은 연습이
  필요할 것 같습니다.

## Step3 구현 목록

- [x] Step2 피드백 반영
- [x] 장바구니 아이템 화면 추가
- [x] 장바구니 목록 화면 추가
- [x] 주문하기 버튼 추가
    - [x] 주문하기 버튼에 가격 총합 표시
- [x] 장바구니 상품 수량 조절 구현
- [x] 장바구니 상품 삭제 구현
    - [x] 삭제 버튼
    - [x] 수량 0인 경우
- [x] 상품 가격 합계 구현
- [x] CartItemView를 Stateless로 리팩터링
- [x] 테스트 코드 작성

## Step3 진행 중 의식의 흐름

- 현업처럼 디자인 가이드에 딱 맞추려고 시도하다 시간이 많이 소비되었습니다. 학습 측면에서도 가이드를 지켜야 하는 것은 맞으나 현재 학습 목적과는 상이한 것 같아서 일단 디테일한
  간격 등은 임의로 두었습니다.
- LazyColumn 아래에 버튼을 고정시키는 것이 의외의 복병이었습니다. LazyColumn은 스크롤이 가능한 컴포넌트이기 때문에 버튼을 고정시키기 위해서는
  LazyColumn을 Box로 감싸고 버튼을 하단에 두면 될 줄 알았습니다. 이 경우 LazyColumn과 버튼의 영역이 겹치는 문제가 있었습니다.
- 다른 시도는 Column으로 감싸고 버튼을 Column의 마지막에 배치하는 것이었습니다. 이것도 잘 안되었습니다. LazyColumn을 감싼 Column에 weight를 주면
  버튼을 제외한 나머지 공간을 차지하기 때문에 버튼이 고정이 되긴 합니다. 하지만 아이템이 1개 추가되면 상단이 아니라 가운데부터 배치되는 문제가 있었습니다.
- Scaffold에서 topBar, bottomBar를 사용해도 LazyColumn의 영역이 topBar, bottomBar를 침범하는 문제가 있었습니다.
  innerPadding의 존재를 발견해서 해결했습니다. 학습 목적에 중요한 부분이 아닐 수 있지만 상당히 많은 매몰비용이 발생했습니다.
- CartItemView는 Stateless로 구성하려고 시도했습니다. 먼저 CartList로 상태 호이스팅 하도록 변경했다가 CartScreen에서 상태를 관리하고
  CartList는 UI를 그리는 작업만 하도록 하는 것이 좋겠다고 생각되었습니다. 그리고 컴포넌트를 좀 더 나눌 수 있을 것 같지만 일단은 하나로 묶었습니다. 나중에 더 나누는
  것도 좋을 것 같습니다.
- CartScreen에 대한 테스트도 필요한가요? 내부에 포함된 컴포넌트에 대한 테스트를 작성하고 CartScreen 테스트 코드를 작성하다 보니 중복되어 작성하지 않았습니다.

## Step2 구현 목록

- [x] Step1 피드백 반영
- [x] 빈 장바구니 화면 추가
- [x] 상품 목록 화면에서 장바구니 화면으로 이동 구현
- [x] 장바구니 화면에서 상품 목록 화면으로 이동 구현
- [x] 상품 상세 화면 추가
- [x] 상품 목록 화면에서 상품 상세 화면으로 이동 구현
- [x] 상품 상세 화면에서 상품 목록 화면으로 이동 구현
- [x] 장바구니 담기 버튼 선택 시 장바구니 화면으로 이동 구현
- [x] 장바구니 화면에서 상품 상세 화면으로 이동 구현
- [x] 테스트 코드 작성

## Step2 진행 중 의식의 흐름

- Parcelable이 기본 세팅 되어 있지 않은 점으로 미루어 볼 때, 이번 미션에서는 사용하지 않는 것이 좋을 것 같다고 판단했습니다. 컴포즈 학습에 집중하기 위해서요.
- 지난 회원가입 미션에서는 컴포저블을 최대한 재활용 해보려고 애쓰다가 불필요한 로직이 추가되었습니다. 이번 미션의 이번 단계에서는 일단 최대한 각 화면을 분리하여 구현해 보려고
  합니다.
- shape = RoundedCornerShape(n.dp)와 Modifier.clip(RoundedCornerShape(n.dp))의 차이점에 대해서 좀 더 알아보고 싶습니다.
  둘 다 라운드 처리를 해주는 것으로 알고 있는데 어떤 차이가 있는지 궁금하기 때문입니다.
- 뒤로 가기 동작은 처음에 무지성으로 Intent를 사용해서 구현했습니다. 그때도 런치 모드를 어떻게 할까 고민하였는데 불필요한 시간이 되었습니다. 왜냐면 직전 화면으로
  돌아가야만 하는 장바구니 화면을 구현하다 보니 onBackPressedDispatcher?.onBackPressed()를 사용하게 되었습니다. 괜찮은 방법인지 궁금합니다.

## Step1 구현 목록

- [x] dummy data 생성
- [x] Glide 설정
- [x] 타이틀 뷰 구현
- [x] 상품 아이템 뷰 구현
- [x] 상품 리스트 뷰 구현
- [x] dummy data 변경
- [x] GlideImage 사이즈 조정
- [x] 테스트 코드 작성
- [x] 피드백 1차 반영

## Step1 진행 중 의식의 흐름

- TDD로 해야 하는데... 하지만 아직 컴포즈 숙달에 좀 더 집중하고자 일단 뷰부터 구현했습니다.
- Title을 만들다가 갑자기 AppBar 관련 컴포넌트가 있을 것 같아서 찾아보니 TopAppBar라는 것이 있는 것을 알게 되었습니다. 그래서 이걸 사용해 보려고 합니다.
- LazyColumn이 있는데 왜 Column이 있을까요? 간단한 레이아웃을 그릴 때는 굳이 LazyColumn을 사용할 필요가 없을 것 같습니다. 예를 들어 스크롤이 발생하면서
  여러 데이터를 갱신할 필요가 없다면 한 번에 렌더링 되면 그만이기 때문입니다.
- ProductItem에서 컴포넌트를 더 나눠야 할까요? 아이템 내부에 각 컴포넌트도 나누면 너무 잘게 나눠진다고 느껴집니다. 그래서 일단은 하나로 묶었습니다.
- modifier를 주입하되 무조건 그렇게 해야 하는 것은 아니라고 수업시간에 언근된 것으로 기억합니다. 현재 LazyVerticalGrid에서 ProductItem의
  파라미터로 modifier를 주입하고 있습니다. 하지만 GlideImage에서 해당 modifier를 사용하면 패딩이 적용된 상태에서 사이즈를 조정하여 렌더링하기 때문에
  의도하지 않은 패딩으로 원하는 UI가 그려지지 않습니다. 그래서 별도의 Modifier를 내부에서 적용하도록 수정했습니다.
- 각_상품의_이미지와_텍스트가_표시된다() 테스트 코드에서 val formattedPrice = NumberFormat.getNumberInstance(Locale.KOREAN)
  .format(product.price)라는 로직을 사용하고 싶지 않습니다. 이런 경우엔 어떻게 테스트하면 좋을까요? ProductItemTest에서 검증된 사항이기도 하지만
  리스트로 보여주는 부분에서 또 확인해야 안정감이 들 것 같아서 시도해 보았습니다.
